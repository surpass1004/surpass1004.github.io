<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01.为什么vue组件中的data要return</title>
    <url>/2022/04/13/01.%E4%B8%BA%E4%BB%80%E4%B9%88vue%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84data%E8%A6%81return/</url>
    <content><![CDATA[<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p> 防止多个组件实例对象之间共用一个data，产生数据污染 </p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>data属于引用数据类型 ,组件多次调用data都是内存的同一个地址，一个数据改变了，那么其他的数据也随之而改变 </p>
<p>如果data是一个函数的话，那么我们每次创建一个新的实例之后，就会调用一个新的<code>data</code>函数。也就是给每一个<code>data</code>数据定义一个新的内存地址。这样的话，修改A而不会影响B. </p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>原理</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>02.Vue双向数据绑定</title>
    <url>/2022/04/13/02.Vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>实现数据变化更新视图，视图变化更新数据</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p> 数据劫持结合发布者-订阅者模式的方式 </p>
<p> 通过 Object.defineProperty() 来劫持各个属性的 setter，getter </p>
<p> 数据变动时发布消息给订阅者，触发相应的监听回调 </p>
<h3 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h3><p>defineProperty就是定义属性的意思</p>
<p>Object.defineProperty()  会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象 </p>
<ol>
<li><p><strong>需要<code>observer</code>对数据对象进行递归遍历</strong>  给对象的属性(包括子属性对象)，都加上 <code>setter</code>和<code>getter</code><br>这样的话，给这个对象的某个值赋值，就会触发<code>setter</code>，那么就能监听到了数据变化 </p>
</li>
<li><p><strong><code>compile</code>解析模板指令  将模板中的变量替换成数据，然后初始化渲染页面视图</strong>  并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 </p>
</li>
<li><p><strong><code>Watcher</code>订阅者作为<code>Observer</code>和<code>Compile</code>之间通信的桥梁</strong> 主要做的事情是 </p>
<p>1、在自身实例化时往属性订阅器(dep)里面添加自己</p>
</li>
</ol>
<p>   2、自身必须有一个<code>update()</code>方法<br>   3、待属性变动<code>dep.notice()</code>通知时，能调用自身的<code>update()</code>方法，并触发<code>Compile</code>中绑定的回调，则功成身退 </p>
<ol start="4">
<li><p><strong>MVVM作为数据绑定的入口，整合<code>Observer</code>、<code>Compile</code>和<code>Watcher</code>三者</strong> </p>
<p>通过<code>Observer</code>来监听自己的<code>model</code>数据变化，通过<code>Compile</code>来解析编译模板指令，最终利用<code>Watcher</code>搭起<code>Observer</code>和<code>Compile</code>之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果</p>
</li>
</ol>
<h4 id="setter、getter"><a href="#setter、getter" class="headerlink" title="setter、getter"></a><strong>setter、getter</strong></h4><p> 对象有两种属性 </p>
<p> 1 . <strong>数据属性</strong>：就是我们经常使用的属性<br> 2 . <strong>访问器属性</strong>：也称存取属性（存取器属性就是一组获取和设置值的<strong>函数</strong>） </p>
<p>定义一个对象在<code>__proto__</code>可找到</p>
<p><code>get __proto__</code></p>
<p><code>set __proto__</code></p>
<p>他们各对应一个函数就是存取器属性</p>
<p>get对应getter 负责获取值，它不带任何参数 </p>
<p>set对应的方法 是setter，负责设置值，在它的函数体中，一切的return都是无效的 </p>
<h4 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h4><p> 可以使用Object.defineProperty定义对象的新属性或修改原有的属性 </p>
<p> 语法：<code>Object.defineProperty(obj, prop, descriptor)</code> </p>
<p><code>obj:</code>必需，目标对象；<br><code> prop :</code>必需，需定义或修改的属性的名字；<br><code> descriptor:</code>必需，目标属性所拥有的特性； </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.defineproperty(obj,name,&#123;</span><br><span class="line">	get:function()&#123;</span><br><span class="line">		console.log(&quot;触发获取&quot;)</span><br><span class="line">		return val</span><br><span class="line">	&#125;</span><br><span class="line">	set:function()&#123;</span><br><span class="line">		console.log(&quot;触发设置&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.name = &#x27;张三&#x27; //触发set</span><br><span class="line">//打印	触发设置</span><br><span class="line"></span><br><span class="line">let val = obj.name //触发get</span><br><span class="line">//打印	触发获取</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
        <category>原理</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>03.路由模式</title>
    <url>/2022/04/13/03.%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="hash-与-history"><a href="#hash-与-history" class="headerlink" title="hash 与 history"></a>hash 与 history</h3><p>在new 的 Router实例中 mode上进行设置 默认hash</p>
<p> hash模式，url中就会存在“#“符号，这个符号后面的是路径 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/#/</span><br><span class="line">http://localhost:8080/#/test </span><br></pre></td></tr></table></figure>

<p> 如果使用history，路径与传统网址一样 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/</span><br><span class="line">http://localhost:8080/test</span><br></pre></td></tr></table></figure>



<h4 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h4><p> url中的路径就是服务端根目录下的相对路径，是<strong>真实路径</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/test/123.html</span><br><span class="line">就需要在根目录下有test文件夹，文件夹下有123.html这个文件 </span><br></pre></td></tr></table></figure>

<p> 如果我们没有这个文件，而是用vue这种router </p>
<p> 就必须用nginx代理，否则找不到这个文件就是返回404 </p>
<p> 在nginx中配置每一个route，漏下一个就会404 </p>
<p> <strong>history模式下的路由分发是服务端（nginx）来做的</strong> </p>
<h4 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a>hash模式</h4><p>hash模式的url中“#“符号后面的路径并不是真实路径，而是以类似参数的形式传给默认文件 </p>
<p>默认文件就是index，在这里通过“#“符号后面的路径去匹配路由处理，所以只要有index这一个文件是真实路径就可以 </p>
<p> <strong>hash模式下的路由分发就不需要服务端来做了，直接在前端</strong>就处理 </p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>路由</category>
        <category>路由模式</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>05.行内与块的区别</title>
    <url>/2022/04/14/05.%E8%A1%8C%E5%86%85%E4%B8%8E%E5%9D%97%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="在流体布局上"><a href="#在流体布局上" class="headerlink" title="在流体布局上"></a>在流体布局上</h3><p>行内在一条直线上排列，只可包含行内</p>
<p>块级独据一行，可包含块级、行块、行内</p>
<h3 id="在盒模型上"><a href="#在盒模型上" class="headerlink" title="在盒模型上"></a>在盒模型上</h3><p>行内宽高无效，margin和padding上下无效</p>
<h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display: block			//块</span><br><span class="line">display: inline-block	//行块</span><br><span class="line">display: inline			//行内</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>04.浏览器内核及兼容前缀</title>
    <url>/2022/04/13/04.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8F%8A%E5%85%BC%E5%AE%B9%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>浏览器</th>
<th>内核</th>
<th>兼容前缀</th>
</tr>
</thead>
<tbody><tr>
<td>IE</td>
<td>Trident</td>
<td>-ms-</td>
</tr>
<tr>
<td>Firefox</td>
<td>Gecko</td>
<td>-moz-</td>
</tr>
<tr>
<td>Opera</td>
<td>blink</td>
<td>-o-</td>
</tr>
<tr>
<td>Chrome</td>
<td>webkit–blink</td>
<td>-webkit-</td>
</tr>
<tr>
<td>safari（苹果）</td>
<td>webkit</td>
<td>-webkit-</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>06.清除浮动</title>
    <url>/2022/04/14/06.%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</url>
    <content><![CDATA[<h3 id="1-父级加固定高"><a href="#1-父级加固定高" class="headerlink" title="1.父级加固定高"></a>1.父级加固定高</h3><p>不适用于内容不确定的元素。内容可能会溢出</p>
<h3 id="2-浮动结束位置加空div标签"><a href="#2-浮动结束位置加空div标签" class="headerlink" title="2.浮动结束位置加空div标签"></a>2.浮动结束位置加空div标签</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.clear&#123;clear: both&#125;</span><br><span class="line"></span><br><span class="line">clear属性： </span><br><span class="line">left </span><br><span class="line">right </span><br><span class="line">both </span><br><span class="line">none</span><br></pre></td></tr></table></figure>



<h3 id="3-父级高不确定，加overflow-hidden"><a href="#3-父级高不确定，加overflow-hidden" class="headerlink" title="3.父级高不确定，加overflow: hidden"></a>3.父级高不确定，加overflow: hidden</h3><p>不适用子集有定位的元素</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>07.this指向与改变</title>
    <url>/2022/04/14/07.this%E6%8C%87%E5%90%91%E4%B8%8E%E6%94%B9%E5%8F%98/</url>
    <content><![CDATA[<h3 id="指向"><a href="#指向" class="headerlink" title="指向"></a>指向</h3><h4 id="1-直接调用-向window"><a href="#1-直接调用-向window" class="headerlink" title="1.直接调用 向window"></a>1.直接调用 向window</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fun() &#123;</span><br><span class="line">	console.log(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun()	//window</span><br></pre></td></tr></table></figure>



<h4 id="2-对象调用-this指向对象-谁调用指向谁"><a href="#2-对象调用-this指向对象-谁调用指向谁" class="headerlink" title="2.对象调用 this指向对象(谁调用指向谁)"></a>2.对象调用 this指向对象(谁调用指向谁)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">	name: &#x27;一个对象&#x27;，</span><br><span class="line">	print: function() &#123;</span><br><span class="line">		console.log(this)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.print() //[object object]</span><br></pre></td></tr></table></figure>



<h4 id="3-箭头函数指向-外层作用域"><a href="#3-箭头函数指向-外层作用域" class="headerlink" title="3.箭头函数指向 外层作用域"></a>3.箭头函数指向 外层作用域</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var test = &#123;</span><br><span class="line">        name: &#x27;test&#x27;,</span><br><span class="line">        print: function() &#123;</span><br><span class="line">            setTimeout(() =&gt;&#123;</span><br><span class="line">                console.log(this)</span><br><span class="line">            &#125; ,100)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test.print() //&#123;name: &#x27;test&#x27;, print: ƒ&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  name: &#x27;张三&#x27;,</span><br><span class="line">  print: function() &#123;</span><br><span class="line">      console.log(this)</span><br><span class="line">      console.log(this.name)</span><br><span class="line">  &#125;,</span><br><span class="line">  fun: () =&gt; &#123;</span><br><span class="line">      console.log(this)</span><br><span class="line">      console.log(this.name)  </span><br><span class="line"></span><br><span class="line">obj.print()	//[object object]	张三</span><br><span class="line">obj.fun()	//[object window]	空字符串</span><br></pre></td></tr></table></figure>

<p> 函数体内的this对象就是<strong>定义时所在的对象</strong>，而<strong>不是使用时所在的对象</strong> </p>
<p> 箭头函数根本<strong>没有自己的this</strong>，导致<strong>内部的this就是外层代码块的this</strong>，也正是因为箭头函数没有this，所以也<strong>不能用作构造函数</strong>。 </p>
<h4 id="4-new-调用-指向被new创建的实例"><a href="#4-new-调用-指向被new创建的实例" class="headerlink" title="4.new 调用 指向被new创建的实例"></a>4.new 调用 指向被new创建的实例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fun() &#123;</span><br><span class="line">	console.log(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fun_one = new fun()	//fun</span><br></pre></td></tr></table></figure>

<p> this永远被绑定在新创建的对象上，任何方式都<strong>改变不了this的指向</strong> </p>
<h3 id="改变指向"><a href="#改变指向" class="headerlink" title="改变指向"></a>改变指向</h3><h3 id="apply-call"><a href="#apply-call" class="headerlink" title="apply() call()"></a>apply() call()</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><h5 id="1-改变this指向"><a href="#1-改变this指向" class="headerlink" title="1.改变this指向"></a>1.改变this指向</h5><h5 id="2-借用别的对象的方法"><a href="#2-借用别的对象的方法" class="headerlink" title="2.借用别的对象的方法"></a>2.借用别的对象的方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function test1(a,b)&#123;</span><br><span class="line">	return a+b;</span><br><span class="line">&#125;</span><br><span class="line">function test2(a,b)&#123;</span><br><span class="line">	return a-b;</span><br><span class="line">&#125;</span><br><span class="line">var a1 = add.apply(sub,[5,4]); //test2调用test1的方法</span><br><span class="line">var a2 = add.call(sub,5,4); //test2调用test1的方法</span><br><span class="line">console.log(a1);  //9</span><br><span class="line">console.log(a2);  //9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">var Man = function()&#123;</span><br><span class="line">	this.name = &quot;张三&quot;;</span><br><span class="line">&#125;</span><br><span class="line">var Woman = function()&#123;</span><br><span class="line">	this.getName = function()&#123;</span><br><span class="line">		console.log(this.name);</span><br><span class="line">	&#125;</span><br><span class="line">	Man.call(this);//this指向Woman，结果相当于给Woman加了name属性</span><br><span class="line">&#125;</span><br><span class="line">var person = new Woman();</span><br><span class="line">person.getName();   //张三</span><br></pre></td></tr></table></figure>



<h5 id="3-单纯的调用函数"><a href="#3-单纯的调用函数" class="headerlink" title="3.单纯的调用函数"></a>3.单纯的调用函数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">    alert(1);</span><br><span class="line">&#125;</span><br><span class="line">test.call();</span><br></pre></td></tr></table></figure>



<h4 id="apply-call-bind区别"><a href="#apply-call-bind区别" class="headerlink" title="apply call bind区别"></a>apply call bind区别</h4><p><strong>相同</strong></p>
<p>都可以<strong>改变this指向</strong>，第一个参数都是要指定的对象</p>
<p><strong>不同</strong></p>
<p>apply只有两个参数，第二个参数为一个数组，需要传输的参数值须全部放到数组中。而call、bind一样，参数用逗号分开</p>
<p> apply、call返回的的是一个值，而bind返回的是一个函数，需要执行这个函数才会得到值 </p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>08.原始数据类型与引用数据类型</title>
    <url>/2022/04/14/08.%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><p> Undefined	Null	Boolean	Number	String   Symbol </p>
<p>被频繁使用的数据  直接<strong>存储在栈</strong>（stack）中的简单数据段，占据<strong>空间小，大小固定</strong></p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>对象 函数 数组</p>
<p> 存储在<strong>堆</strong>（heap）中的对象，占据<strong>空间大，大小不固定</strong> </p>
<h3 id="鉴别类型"><a href="#鉴别类型" class="headerlink" title="鉴别类型"></a>鉴别类型</h3><h4 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(typeof &#x27;a&#x27;);           // &quot;string&quot;</span><br><span class="line">console.log(typeof 1);            // &quot;number&quot;</span><br><span class="line">console.log(typeof false);         // &quot;boolean&quot;</span><br><span class="line">console.log(typeof undefined);     // &quot;undefined&quot;</span><br><span class="line">console.log(typeof null);         // &quot;object&quot;</span><br></pre></td></tr></table></figure>

<h5 id="为什么typeof-null-返回object"><a href="#为什么typeof-null-返回object" class="headerlink" title="为什么typeof(null)返回object"></a>为什么typeof(null)返回object</h5><p>这是个bug	javascript中不同对象在底层都表示为二进制，而javascript 中会把二进制前三位都为0的判断为object类型，而null的二进制表示全都是0	所以执行typeof时会返回 ‘object’。 </p>
<h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = []</span><br><span class="line">let b = &#123;&#125;</span><br><span class="line">let c = function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">console.log(typeof a);      // &quot;object&quot;</span><br><span class="line">console.log(typeof b);     	// &quot;object&quot;</span><br><span class="line">console.log(typeof c);      // &quot;function&quot;</span><br></pre></td></tr></table></figure>

<p>但这区分不了数组与对象</p>
<p>所以可以使用 instanceof</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">var b = &#123;&#125;;</span><br><span class="line">var c = function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">console.log(a instanceof Array);       // true</span><br><span class="line">console.log(b instanceof Object);     // true</span><br><span class="line">console.log(c instanceof Function);  // true</span><br></pre></td></tr></table></figure>

<p>另外Array.isArray()鉴定数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">console.log(Array.isArray(a)); // true</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>09.对象深度克隆</title>
    <url>/2022/04/14/09-%E5%AF%B9%E8%B1%A1%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86/</url>
    <content><![CDATA[<h3 id="方法一、对象序列化再解析"><a href="#方法一、对象序列化再解析" class="headerlink" title="方法一、对象序列化再解析"></a>方法一、对象序列化再解析</h3><p>缺点：无法克隆方法 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  a:1,</span><br><span class="line">  b:&#x27;wee&#x27;,</span><br><span class="line">  sds:function()&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">  &#125;,</span><br><span class="line">  ds:&#123;</span><br><span class="line">    dksk:1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var newObj = JSON.parse(JSON.stringify(obj));</span><br></pre></td></tr></table></figure>



<h3 id="方法二、写一个方法"><a href="#方法二、写一个方法" class="headerlink" title="方法二、写一个方法"></a>方法二、写一个方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function deepClone(obj) &#123;</span><br><span class="line">    var newobj = obj.constructor === Array ? [] : &#123;&#125;;</span><br><span class="line">    for (var i in obj) &#123;</span><br><span class="line">    	newobj[i] = typeof obj[i] === &#x27;object&#x27; ? cloneObj(obj[i]) : obj[i]; </span><br><span class="line">    &#125;</span><br><span class="line">    return newobj; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var newObj = deepClone(obj));</span><br></pre></td></tr></table></figure>



<h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = [1,1,2,3,4,4,5,6,6,7]</span><br><span class="line"></span><br><span class="line">let b = new Set(a)</span><br><span class="line">console.log(b)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>10.同步异步、微任务与宏任务</title>
    <url>/2022/04/14/10-%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E3%80%81%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%8F%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h3 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h3><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a><strong>同步</strong></h4><p> 在主线程上排队执行的任务 </p>
<p> 前一个任务执行完毕，才能继续执行下一个任务 </p>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a><strong>异步</strong></h4><p> 不进入主线程、而进入”任务队列”的任务</p>
<p>只有等主线程任务执行完毕，”任务队列”的任务才会进入主线程执行</p>
<h3 id="宏任务-和-微任务"><a href="#宏任务-和-微任务" class="headerlink" title="宏任务 和 微任务"></a>宏任务 和 微任务</h3><p> 异步任务分为 宏任务 和 微任务 </p>
<h4 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h4><p>settimeout setInterval script(最外层的script标签)</p>
<p> 栈清空之后再执行 </p>
<h4 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h4><p>promise(async await) </p>
<p>调用栈清空时立即执行(优先级大于宏任务), 调用栈中加入的微任务会立马执行 </p>
<p><strong>总结</strong></p>
<p>先同步在异步</p>
<p>先微任务再宏任务</p>
<p>微任务队列上创建的宏任务会被后添加到当前宏任务队列的尾端，微任务队列中创建的微任务会被添加到微任务队列的尾端 </p>
<p>只要微任务队列中还有任务，宏任务队列等待 </p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>11.get与post区别</title>
    <url>/2022/04/14/11-get%E4%B8%8Epost%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<ol>
<li><p>GET请求在URL中传送的参数是有长度限制的，而POST没有</p>
</li>
<li><p>POST比GET更安全，因为参数直接暴露在URL上，而POST数据是放在Request body中 </p>
</li>
<li><p>参数的数据类型，GET只接受ASCII字符，而POST没有限制 </p>
</li>
<li><p>GET请求参数会保留在浏览器历史记录里；POST不会</p>
</li>
<li><p>GET请求只能进行url编码（application&#x2F;x-www-form-urlencoded），而POST支持多种编码方式</p>
</li>
<li><p>GET请求会被浏览器缓存，而POST不会，但可手动设置。 </p>
</li>
<li><p>GET在浏览器回退时是无害的，而POST会再次提交请求 </p>
</li>
<li><p>GET产生一个TCP数据包；POST产生两个TCP数据包 </p>
<p>GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；<br>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">四种常见的 POST 提交数据方式</span><br><span class="line">application/x-www-form-urlencoded</span><br><span class="line">multipart/form-data</span><br><span class="line">application/json</span><br><span class="line">text/xml</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>12.跨域解决方案</title>
    <url>/2022/04/14/12-%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p> ajax请求的url中的传输协议、域名、端口号，有任意一个不同时，就会触发同源策略 </p>
<h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><p><strong>原理</strong></p>
<p> script的src属性不受浏览器同源策略限制，可以通过该属性进行跨域请求 </p>
<p> jsonp技术就是让后端返回一个函数调用，把数据作为实参给前端定义好的形参，从而实现数据的接收 </p>
<h3 id="cors"><a href="#cors" class="headerlink" title="cors"></a>cors</h3><p>cors跨域是后端响应头的配置，在后端语言中配置的</p>
<p>副作用最小的，在应用场景中使用最多的跨域方式 </p>
<h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><p> proxy 代理跨域（让服务器代理跨域） </p>
<p>浏览器同源设置一个代理服务器 </p>
<p>把本该发送给目标服务器的请求发送给代理服务器</p>
<p>代理服务器转发请求给目标服务器，目标服务器会把响应给代理服务器，代理服务器再把响应给到浏览器 </p>
]]></content>
      <categories>
        <category>HTTP</category>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>关于hexo的操作</title>
    <url>/2022/04/11/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="hexo的基本操作"><a href="#hexo的基本操作" class="headerlink" title="hexo的基本操作"></a>hexo的基本操作</h2><span id="more"></span>

<h3 id="创建一个页面"><a href="#创建一个页面" class="headerlink" title="创建一个页面"></a>创建一个页面</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//新建一个标题为 name 的页面，默认链接地址为主页地址/name / </span><br><span class="line">hexo new/n page name 	</span><br><span class="line"></span><br><span class="line">//在生成的.md文件配置</span><br><span class="line">title: 与_config.yml文件中 meun 配置一致</span><br><span class="line">date: </span><br><span class="line">type: 与_config.yml文件中 meun 配置的值一致</span><br><span class="line">layout: 打开的页面，尽量与type一致</span><br></pre></td></tr></table></figure>



<h3 id="创建博客文章"><a href="#创建博客文章" class="headerlink" title="创建博客文章"></a>创建博客文章</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//清除所有记录 </span><br><span class="line">hexo clean	</span><br><span class="line"></span><br><span class="line">//新建一个标题为 name 的文章 在你的blog/source/_posts下 name .md</span><br><span class="line">hexo new/n &quot;name &quot; </span><br><span class="line"></span><br><span class="line">//生成静态网页  到默认设置的 public 文件夹 </span><br><span class="line">hexo generate/g		</span><br><span class="line"></span><br><span class="line">//生成静态网页   并部署到设定的仓库 </span><br><span class="line">hexo deploy/d 	</span><br><span class="line"></span><br><span class="line">//启动服务 </span><br><span class="line">hexo server/s 	</span><br></pre></td></tr></table></figure>



<h3 id="配置分类或标签"><a href="#配置分类或标签" class="headerlink" title="配置分类或标签"></a>配置分类或标签</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//标题</span><br><span class="line">tags: name</span><br><span class="line"></span><br><span class="line">//分类</span><br><span class="line">categories: namae</span><br><span class="line"></span><br><span class="line">//多级分类</span><br><span class="line">categories:</span><br><span class="line">  - 主分类</span><br><span class="line">  - 次分类</span><br><span class="line">//或者</span><br><span class="line">categories: [主分类,次分类]</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p> <a href="https://hexo.io/themes/">Themes | Hexo</a> </p>
<p>cd 博客目录</p>
<p>git clone 主题url</p>
<p> 将博客根目录下的 <code>_config.yml</code> 里的 <code>theme</code> 值修改成下载的主题</p>
<p>例：本博客采用Ayer</p>
<p>详情见	 <a href="https://shen-yu.gitee.io/2019/ayer/#%E5%AE%89%E8%A3%85">Ayer中文说明 | 岛 (gitee.io)</a> </p>
<h3 id="配置到远程仓库（码云）"><a href="#配置到远程仓库（码云）" class="headerlink" title="配置到远程仓库（码云）"></a>配置到远程仓库（码云）</h3><p>参考 <a href="https://blog.csdn.net/cungudafa/article/details/104260494?ops_request_misc=%7B%22request_id%22:%22164969418816782089398873%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=164969418816782089398873&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-104260494.142%5Ev7%5Epc_search_result_control_group,157%5Ev4%5Econtrol&utm_term=hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%B0gitee&spm=1018.2226.3001.4187">基于Gitee+Hexo搭建个人博客_cungudafa的博客-CSDN博客_gitee个人博客模板</a> </p>
<p>项目目录下 _config.yml 文件 修改 </p>
<p> ：后都有一个空格 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: 你的项目地址（https）</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>部署</p>
<p>需要下载插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save	</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g --d  #一键部署</span><br></pre></td></tr></table></figure>

<p>每次添加文件都要手动在gitee更新</p>
]]></content>
      <categories>
        <category>操作</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/04/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
