<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01.为什么vue组件中的data要return</title>
    <url>/2022/04/13/01.%E4%B8%BA%E4%BB%80%E4%B9%88vue%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84data%E8%A6%81return/</url>
    <content><![CDATA[<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p> 防止多个组件实例对象之间共用一个data，产生数据污染 </p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>data属于引用数据类型 ,组件多次调用data都是内存的同一个地址，一个数据改变了，那么其他的数据也随之而改变 </p>
<p>如果data是一个函数的话，那么我们每次创建一个新的实例之后，就会调用一个新的<code>data</code>函数。也就是给每一个<code>data</code>数据定义一个新的内存地址。这样的话，修改A而不会影响B. </p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>原理</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>03.路由模式</title>
    <url>/2022/04/13/03.%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="hash-与-history"><a href="#hash-与-history" class="headerlink" title="hash 与 history"></a>hash 与 history</h3><p>在new 的 Router实例中 mode上进行设置 默认hash</p>
<p> hash模式，url中就会存在“#“符号，这个符号后面的是路径 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/#/</span><br><span class="line">http://localhost:8080/#/test </span><br></pre></td></tr></table></figure>

<p> 如果使用history，路径与传统网址一样 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/</span><br><span class="line">http://localhost:8080/test</span><br></pre></td></tr></table></figure>



<h4 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h4><p> url中的路径就是服务端根目录下的相对路径，是<strong>真实路径</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/test/123.html</span><br><span class="line">就需要在根目录下有test文件夹，文件夹下有123.html这个文件 </span><br></pre></td></tr></table></figure>

<p> 如果我们没有这个文件，而是用vue这种router </p>
<p> 就必须用nginx代理，否则找不到这个文件就是返回404 </p>
<p> 在nginx中配置每一个route，漏下一个就会404 </p>
<p> <strong>history模式下的路由分发是服务端（nginx）来做的</strong> </p>
<h4 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a>hash模式</h4><p>hash模式的url中“#“符号后面的路径并不是真实路径，而是以类似参数的形式传给默认文件 </p>
<p>默认文件就是index，在这里通过“#“符号后面的路径去匹配路由处理，所以只要有index这一个文件是真实路径就可以 </p>
<p> <strong>hash模式下的路由分发就不需要服务端来做了，直接在前端</strong>就处理 </p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>路由</category>
        <category>路由模式</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>02.Vue双向数据绑定</title>
    <url>/2022/04/13/02.Vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>实现数据变化更新视图，视图变化更新数据</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p> 数据劫持结合发布者-订阅者模式的方式 </p>
<p> 通过 Object.defineProperty() 来劫持各个属性的 setter，getter </p>
<p> 数据变动时发布消息给订阅者，触发相应的监听回调 </p>
<h3 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h3><p>defineProperty就是定义属性的意思</p>
<p>Object.defineProperty()  会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象 </p>
<ol>
<li><p><strong>需要<code>observer</code>对数据对象进行递归遍历</strong>  给对象的属性(包括子属性对象)，都加上 <code>setter</code>和<code>getter</code><br>这样的话，给这个对象的某个值赋值，就会触发<code>setter</code>，那么就能监听到了数据变化 </p>
</li>
<li><p><strong><code>compile</code>解析模板指令  将模板中的变量替换成数据，然后初始化渲染页面视图</strong>  并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 </p>
</li>
<li><p><strong><code>Watcher</code>订阅者作为<code>Observer</code>和<code>Compile</code>之间通信的桥梁</strong> 主要做的事情是 </p>
<p>1、在自身实例化时往属性订阅器(dep)里面添加自己</p>
</li>
</ol>
<p>   2、自身必须有一个<code>update()</code>方法<br>   3、待属性变动<code>dep.notice()</code>通知时，能调用自身的<code>update()</code>方法，并触发<code>Compile</code>中绑定的回调，则功成身退 </p>
<ol start="4">
<li><p><strong>MVVM作为数据绑定的入口，整合<code>Observer</code>、<code>Compile</code>和<code>Watcher</code>三者</strong> </p>
<p>通过<code>Observer</code>来监听自己的<code>model</code>数据变化，通过<code>Compile</code>来解析编译模板指令，最终利用<code>Watcher</code>搭起<code>Observer</code>和<code>Compile</code>之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果</p>
</li>
</ol>
<h4 id="setter、getter"><a href="#setter、getter" class="headerlink" title="setter、getter"></a><strong>setter、getter</strong></h4><p> 对象有两种属性 </p>
<p> 1 . <strong>数据属性</strong>：就是我们经常使用的属性<br> 2 . <strong>访问器属性</strong>：也称存取属性（存取器属性就是一组获取和设置值的<strong>函数</strong>） </p>
<p>定义一个对象在<code>__proto__</code>可找到</p>
<p><code>get __proto__</code></p>
<p><code>set __proto__</code></p>
<p>他们各对应一个函数就是存取器属性</p>
<p>get对应getter 负责获取值，它不带任何参数 </p>
<p>set对应的方法 是setter，负责设置值，在它的函数体中，一切的return都是无效的 </p>
<h4 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h4><p> 可以使用Object.defineProperty定义对象的新属性或修改原有的属性 </p>
<p> 语法：<code>Object.defineProperty(obj, prop, descriptor)</code> </p>
<p><code>obj:</code>必需，目标对象；<br><code> prop :</code>必需，需定义或修改的属性的名字；<br><code> descriptor:</code>必需，目标属性所拥有的特性； </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.defineproperty(obj,name,&#123;</span><br><span class="line">	get:function()&#123;</span><br><span class="line">		console.log(&quot;触发获取&quot;)</span><br><span class="line">		return val</span><br><span class="line">	&#125;</span><br><span class="line">	set:function()&#123;</span><br><span class="line">		console.log(&quot;触发设置&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.name = &#x27;张三&#x27; //触发set</span><br><span class="line">//打印	触发设置</span><br><span class="line"></span><br><span class="line">let val = obj.name //触发get</span><br><span class="line">//打印	触发获取</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
        <category>原理</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>05.行内与块的区别</title>
    <url>/2022/04/14/05.%E8%A1%8C%E5%86%85%E4%B8%8E%E5%9D%97%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="在流体布局上"><a href="#在流体布局上" class="headerlink" title="在流体布局上"></a>在流体布局上</h3><p>行内在一条直线上排列，只可包含行内</p>
<p>块级独据一行，可包含块级、行块、行内</p>
<h3 id="在盒模型上"><a href="#在盒模型上" class="headerlink" title="在盒模型上"></a>在盒模型上</h3><p>行内宽高无效，margin和padding上下无效</p>
<h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display: block			//块</span><br><span class="line">display: inline-block	//行块</span><br><span class="line">display: inline			//行内</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>04.浏览器内核及兼容前缀</title>
    <url>/2022/04/13/04.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%8F%8A%E5%85%BC%E5%AE%B9%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>浏览器</th>
<th>内核</th>
<th>兼容前缀</th>
</tr>
</thead>
<tbody><tr>
<td>IE</td>
<td>Trident</td>
<td>-ms-</td>
</tr>
<tr>
<td>Firefox</td>
<td>Gecko</td>
<td>-moz-</td>
</tr>
<tr>
<td>Opera</td>
<td>blink</td>
<td>-o-</td>
</tr>
<tr>
<td>Chrome</td>
<td>webkit–blink</td>
<td>-webkit-</td>
</tr>
<tr>
<td>safari（苹果）</td>
<td>webkit</td>
<td>-webkit-</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>08.原始数据类型与引用数据类型</title>
    <url>/2022/04/14/08.%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><p> Undefined	Null	Boolean	Number	String   Symbol </p>
<p>被频繁使用的数据  直接<strong>存储在栈</strong>（stack）中的简单数据段，占据<strong>空间小，大小固定</strong></p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>对象 函数 数组</p>
<p> 存储在<strong>堆</strong>（heap）中的对象，占据<strong>空间大，大小不固定</strong> </p>
<h3 id="鉴别类型"><a href="#鉴别类型" class="headerlink" title="鉴别类型"></a>鉴别类型</h3><h4 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&#x27;a&#x27;</span>);           <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">1</span>);            <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">false</span>);         <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>);     <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>);         <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="为什么typeof-null-返回object"><a href="#为什么typeof-null-返回object" class="headerlink" title="为什么typeof(null)返回object"></a>为什么typeof(null)返回object</h5><p>这是个bug	javascript中不同对象在底层都表示为二进制，而javascript 中会把二进制前三位都为0的判断为object类型，而null的二进制表示全都是0	所以执行typeof时会返回 ‘object’。 </p>
<h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = []</span><br><span class="line"><span class="keyword">let</span> b = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a);      <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> b);     	<span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> c);      <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure>

<p>但这区分不了数组与对象</p>
<p>所以可以使用 instanceof</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a <span class="keyword">instanceof</span> <span class="title class_">Array</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b <span class="keyword">instanceof</span> <span class="title class_">Object</span>);     <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c <span class="keyword">instanceof</span> <span class="title class_">Function</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>另外Array.isArray()鉴定数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(a)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>06.清除浮动</title>
    <url>/2022/04/14/06.%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</url>
    <content><![CDATA[<h3 id="1-父级加固定高"><a href="#1-父级加固定高" class="headerlink" title="1.父级加固定高"></a>1.父级加固定高</h3><p>不适用于内容不确定的元素。内容可能会溢出</p>
<h3 id="2-浮动结束位置加空div标签"><a href="#2-浮动结束位置加空div标签" class="headerlink" title="2.浮动结束位置加空div标签"></a>2.浮动结束位置加空div标签</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.clear&#123;clear: both&#125;</span><br><span class="line"></span><br><span class="line">clear属性： </span><br><span class="line">left </span><br><span class="line">right </span><br><span class="line">both </span><br><span class="line">none</span><br></pre></td></tr></table></figure>



<h3 id="3-父级高不确定，加overflow-hidden"><a href="#3-父级高不确定，加overflow-hidden" class="headerlink" title="3.父级高不确定，加overflow: hidden"></a>3.父级高不确定，加overflow: hidden</h3><p>不适用子集有定位的元素</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>07.this指向与改变</title>
    <url>/2022/04/14/07.this%E6%8C%87%E5%90%91%E4%B8%8E%E6%94%B9%E5%8F%98/</url>
    <content><![CDATA[<h3 id="指向"><a href="#指向" class="headerlink" title="指向"></a>指向</h3><h4 id="1-直接调用-向window"><a href="#1-直接调用-向window" class="headerlink" title="1.直接调用 向window"></a>1.直接调用 向window</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fun</span>()	<span class="comment">//window</span></span><br></pre></td></tr></table></figure>



<h4 id="2-对象调用-this指向对象-谁调用指向谁"><a href="#2-对象调用-this指向对象-谁调用指向谁" class="headerlink" title="2.对象调用 this指向对象(谁调用指向谁)"></a>2.对象调用 this指向对象(谁调用指向谁)</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;一个对象&#x27;</span>，</span><br><span class="line">	<span class="attr">print</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">print</span>() <span class="comment">//[object object]</span></span><br></pre></td></tr></table></figure>



<h4 id="3-箭头函数指向-外层作用域"><a href="#3-箭头函数指向-外层作用域" class="headerlink" title="3.箭头函数指向 外层作用域"></a>3.箭头函数指向 外层作用域</h4><p>不绑定this关键字，指向函数定义位置的作用域中的this</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">        <span class="attr">print</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">            &#125; ,<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test.<span class="title function_">print</span>() <span class="comment">//&#123;name: &#x27;test&#x27;, print: ƒ&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">print</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">fun</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)  </span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">print</span>()	<span class="comment">//[object object]	张三</span></span><br><span class="line">obj.<span class="title function_">fun</span>()	<span class="comment">//[object window]	空字符串</span></span><br></pre></td></tr></table></figure>

<p> 函数体内的this对象就是<strong>定义时所在的对象</strong>，而<strong>不是使用时所在的对象</strong> </p>
<p> 箭头函数根本<strong>没有自己的this</strong>，导致<strong>内部的this就是外层代码块的this</strong>，也正是因为箭头函数没有this，所以也<strong>不能用作构造函数</strong>。 </p>
<h4 id="4-new-调用-指向被new创建的实例"><a href="#4-new-调用-指向被new创建的实例" class="headerlink" title="4.new 调用 指向被new创建的实例"></a>4.new 调用 指向被new创建的实例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fun_one = <span class="keyword">new</span> <span class="title function_">fun</span>()	<span class="comment">//fun</span></span><br></pre></td></tr></table></figure>

<p> this永远被绑定在新创建的对象上，任何方式都<strong>改变不了this的指向</strong> </p>
<h3 id="改变指向"><a href="#改变指向" class="headerlink" title="改变指向"></a>改变指向</h3><h3 id="apply-call"><a href="#apply-call" class="headerlink" title="apply() call()"></a>apply() call()</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><h5 id="1-改变this指向"><a href="#1-改变this指向" class="headerlink" title="1.改变this指向"></a>1.改变this指向</h5><h5 id="2-借用别的对象的方法"><a href="#2-借用别的对象的方法" class="headerlink" title="2.借用别的对象的方法"></a>2.借用别的对象的方法</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test1</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test2</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a1 = add.<span class="title function_">apply</span>(sub,[<span class="number">5</span>,<span class="number">4</span>]); <span class="comment">//test2调用test1的方法</span></span><br><span class="line"><span class="keyword">var</span> a2 = add.<span class="title function_">call</span>(sub,<span class="number">5</span>,<span class="number">4</span>); <span class="comment">//test2调用test1的方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1);  <span class="comment">//9</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a2);  <span class="comment">//9</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Man</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Woman</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="title class_">Man</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);<span class="comment">//this指向Woman，结果相当于给Woman加了name属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Woman</span>();</span><br><span class="line">person.<span class="title function_">getName</span>();   <span class="comment">//张三</span></span><br></pre></td></tr></table></figure>



<h5 id="3-单纯的调用函数"><a href="#3-单纯的调用函数" class="headerlink" title="3.单纯的调用函数"></a>3.单纯的调用函数</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">test.<span class="title function_">call</span>();</span><br></pre></td></tr></table></figure>



<h4 id="apply-call-bind区别"><a href="#apply-call-bind区别" class="headerlink" title="apply call bind区别"></a>apply call bind区别</h4><p><strong>相同</strong></p>
<p>都可以<strong>改变this指向</strong>，第一个参数都是要指定的对象</p>
<p><strong>不同</strong></p>
<p>apply只有两个参数，第二个参数为一个数组，需要传输的参数值须全部放到数组中。而call、bind一样，参数用逗号分开</p>
<p> apply、call返回的的是一个值，而bind返回的是一个函数，需要执行这个函数才会得到值 </p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>09.对象深度克隆</title>
    <url>/2022/04/14/09-%E5%AF%B9%E8%B1%A1%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86/</url>
    <content><![CDATA[<h3 id="方法一、对象序列化再解析"><a href="#方法一、对象序列化再解析" class="headerlink" title="方法一、对象序列化再解析"></a>方法一、对象序列化再解析</h3><p>缺点：无法克隆方法 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>:<span class="string">&#x27;wee&#x27;</span>,</span><br><span class="line">  <span class="attr">sds</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">ds</span>:&#123;</span><br><span class="line">    <span class="attr">dksk</span>:<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br></pre></td></tr></table></figure>



<h3 id="方法二、写一个方法"><a href="#方法二、写一个方法" class="headerlink" title="方法二、写一个方法"></a>方法二、写一个方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> newobj = obj.<span class="property">constructor</span> === <span class="title class_">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    	newobj[i] = <span class="keyword">typeof</span> obj[i] === <span class="string">&#x27;object&#x27;</span> ? <span class="title function_">cloneObj</span>(obj[i]) : obj[i]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newobj; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newObj = <span class="title function_">deepClone</span>(obj));</span><br></pre></td></tr></table></figure>



<h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Set</span>(a)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>10.同步异步、微任务与宏任务 EventLoop</title>
    <url>/2022/04/14/10-%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E3%80%81%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%8F%E4%BB%BB%E5%8A%A1%20EventLoop%20/</url>
    <content><![CDATA[<h3 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h3><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a><strong>同步</strong></h4><p> 在主线程上排队执行的任务 </p>
<p> 前一个任务执行完毕，才能继续执行下一个任务 </p>
<h4 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h4><p><strong>事件循环</strong></p>
<p> 种解决<code>javaScript</code>单线程运行时不会阻塞的一种机制，也就是我们经常使用<strong>异步</strong>的原理 </p>
<h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a><strong>堆</strong></h5><p>表示一大块非结构化的<strong>内存区域</strong>，存放<strong>对象，数据</strong> </p>
<h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a><strong>栈</strong></h5><p>是一种后进先出的<strong>数组结构</strong>，</p>
<p>js 有一个 <strong>主线程</strong>和 <strong>调用栈</strong>(执行栈 )</p>
<p>函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空 </p>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a><strong>异步</strong></h4><p> 所有同步任务都在主线程上执行 </p>
<p> 异步进入”任务队列”等待</p>
<p> 所有同步任务执行完毕 ， 系统就会读取”任务队列” </p>
<p> 主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为<strong>Event Loop</strong>（事件循环） </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;start&quot;</span>)	<span class="comment">//①</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;		</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)		<span class="comment">//④⑥</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;		</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)		<span class="comment">//③⑤</span></span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;end&quot;</span>)		<span class="comment">//②</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//start					主线程执行①	</span></span><br><span class="line"><span class="comment">//end					主线程执行②</span></span><br><span class="line"><span class="comment">//2						添加到任务队列③	执行任务队列⑤</span></span><br><span class="line"><span class="comment">//1						添加到任务队列④	执行任务队列⑥</span></span><br></pre></td></tr></table></figure>



<h5 id="宏任务-和-微任务"><a href="#宏任务-和-微任务" class="headerlink" title="宏任务 和 微任务"></a>宏任务 和 微任务</h5><p> ES6将异步任务分为 宏任务 和 微任务 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)					<span class="comment">//①</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;					<span class="comment">//④</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)						<span class="comment">//⑦</span></span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;		<span class="comment">//③</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)						<span class="comment">//⑤</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)						<span class="comment">//⑥</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>)						<span class="comment">//②</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// start			主线程执行①</span></span><br><span class="line"><span class="comment">// end				主线程执行②</span></span><br><span class="line"><span class="comment">// 2				微任务添加到任务队列③	执行任务队列中微任务⑤</span></span><br><span class="line"><span class="comment">// 3				执行任务队列中微任务⑥</span></span><br><span class="line"><span class="comment">// 1				宏任务添加到任务队列④ 执行任务队列中宏任务⑦</span></span><br></pre></td></tr></table></figure>



<h6 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h6><p>settimeout setInterval script(最外层的script标签)</p>
<p> 栈清空之后再执行 </p>
<h6 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h6><p>promise(async await) </p>
<p>调用栈清空时立即执行(优先级大于宏任务), 调用栈中加入的微任务会立马执行 </p>
<p><strong>总结</strong></p>
<p>先同步在异步</p>
<p>先微任务再宏任务</p>
<p>微任务队列上创建的宏任务会被后添加到当前宏任务队列的尾端，微任务队列中创建的微任务会被添加到微任务队列的尾端 </p>
<p>只要微任务队列中还有任务，宏任务队列等待 </p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>11.get与post区别</title>
    <url>/2022/04/14/11-get%E4%B8%8Epost%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<ol>
<li><p>GET请求在URL中传送的参数是有长度限制的，而POST没有</p>
</li>
<li><p>POST比GET更安全，因为参数直接暴露在URL上，而POST数据是放在Request body中 </p>
</li>
<li><p>参数的数据类型，GET只接受ASCII字符，而POST没有限制 </p>
</li>
<li><p>GET请求参数会保留在浏览器历史记录里；POST不会</p>
</li>
<li><p>GET请求只能进行url编码（application&#x2F;x-www-form-urlencoded），而POST支持多种编码方式</p>
</li>
<li><p>GET请求会被浏览器缓存，而POST不会，但可手动设置。 </p>
</li>
<li><p>GET在浏览器回退时是无害的，而POST会再次提交请求 </p>
</li>
<li><p>GET产生一个TCP数据包；POST产生两个TCP数据包 </p>
<p>GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；<br>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">四种常见的 POST 提交数据方式</span><br><span class="line">application/x-www-form-urlencoded</span><br><span class="line">multipart/form-data</span><br><span class="line">application/json</span><br><span class="line">text/xml</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>12.跨域解决方案</title>
    <url>/2022/04/14/12-%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p> ajax请求的url中的传输协议、域名、端口号，有任意一个不同时，就会触发同源策略 </p>
<h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><p><strong>原理</strong></p>
<p> script的src属性不受浏览器同源策略限制，可以通过该属性进行跨域请求 </p>
<p> jsonp技术就是让后端返回一个函数调用，把数据作为实参给前端定义好的形参，从而实现数据的接收 </p>
<h3 id="cors"><a href="#cors" class="headerlink" title="cors"></a>cors</h3><p>cors跨域是后端响应头的配置，在后端语言中配置的</p>
<p>副作用最小的，在应用场景中使用最多的跨域方式 </p>
<h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><p> proxy 代理跨域（让服务器代理跨域） </p>
<p>浏览器同源设置一个代理服务器 </p>
<p>把本该发送给目标服务器的请求发送给代理服务器</p>
<p>代理服务器转发请求给目标服务器，目标服务器会把响应给代理服务器，代理服务器再把响应给到浏览器 </p>
]]></content>
      <categories>
        <category>HTTP</category>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>13.浏览器渲染原理及优化</title>
    <url>/2022/04/14/13-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>为了提升浏览器的稳定性和安全性  浏览器采用了<strong>多进程模型</strong> </p>
<p>进程是操作系统资源分配的基本单位，<strong>进程中包含线程</strong></p>
<h4 id="优化方向：进程"><a href="#优化方向：进程" class="headerlink" title="优化方向：进程"></a>优化方向：进程</h4><p>包括</p>
<p><strong>浏览器进程</strong>：负责显示界面，用户交互，子进程管理，储存</p>
<p><strong>渲染进程</strong>：每个页面有单独的渲染进程，用于渲染界面</p>
<p><strong>网络进程</strong>：处理网络资源加载html css js等</p>
<p><strong>GPU进程</strong>：3d绘制，提高性能</p>
<p><strong>插件进程</strong>：浏览器安装的插件</p>
<h4 id="优化方向：线程"><a href="#优化方向：线程" class="headerlink" title="优化方向：线程"></a>优化方向：线程</h4><p>GUI渲染线程</p>
<p>js引擎线程</p>
<p>事件触发线程</p>
<p>要进行具体优化，我们要知道</p>
<h4 id="从输入url地址到浏览器显示界面都发生了什么"><a href="#从输入url地址到浏览器显示界面都发生了什么" class="headerlink" title="从输入url地址到浏览器显示界面都发生了什么"></a>从输入url地址到浏览器显示界面都发生了什么</h4><h5 id="一、DNS域名解析"><a href="#一、DNS域名解析" class="headerlink" title="一、DNS域名解析"></a>一、DNS域名解析</h5><p>根据输入url找到真实ip地址</p>
<p>以</p>
<p><strong>浏览器缓存</strong>	&gt;	<strong>操作系统缓存</strong>	&gt;	<strong>路由器缓存</strong>	&gt;	<strong>hosts文件缓存</strong></p>
<p>如果缓存没有则<strong>查询DNS服务器</strong> 顶级域名&gt;二级域名….</p>
<h5 id="二、建立TCP连接"><a href="#二、建立TCP连接" class="headerlink" title="二、建立TCP连接"></a>二、建立TCP连接</h5><p>根据 IP 地址，客户端与服务端三次握手建立连接</p>
<h6 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h6><p>1.发送端首先给接收端发送一个带SYN标志的数据包<br>2.接收端收到后，回传一个带有SYN&#x2F;ACK标志的数据包以表示正确传达，并确认信息<br>3.发送端再回传一个带ACK标志的数据包，代表“握手”结束</p>
<p><strong>浏览器构造一个 http 请 求</strong></p>
<p>请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数 据，</p>
<p>并将这个 http 请求封装在一个 tcp 包中，这个 tcp 包会依次经过传输层，网络层， 数据链路层，物理层到达服务器，<strong>服务器解析</strong>这个请求来作出响应，<strong>返回相应的 html 给浏览器</strong></p>
<h5 id="三、传输数据"><a href="#三、传输数据" class="headerlink" title="三、传输数据"></a>三、传输数据</h5><p>服务器接收到请求后，返回请求静态资源，并同时调用 服务器请求接口数据</p>
<h5 id="四、关闭TCP连接"><a href="#四、关闭TCP连接" class="headerlink" title="四、关闭TCP连接"></a>四、关闭TCP连接</h5><h6 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h6><p>数据传输完成，客户端与服务端进行四次挥手，关闭连接</p>
<p>1.关闭方<strong>发送一个FIN</strong> 告知关闭数据传送</p>
<p>2.收到FIN包后，给对方<strong>发送一个ACK</strong>，确认序号为收到序号+1</p>
<p>3.发送ACK后<strong>再发送一个FIN</strong>告知关闭数据传送</p>
<p>4.收到FIN后，<strong>发送一个ACK</strong>，确认序号为收到序号+1</p>
<p>完成四次握手</p>
<h5 id="五、渲染页面"><a href="#五、渲染页面" class="headerlink" title="五、渲染页面"></a>五、渲染页面</h5><p>浏览器根据服务端返回的静态资源</p>
<p>根据<strong>GUI引擎渲染</strong>HTML 和 CSS</p>
<p><strong>js引擎</strong>加载js脚本</p>
<p>浏览器根据这个 html 来构建 DOM 树，在 dom 树的构建过程中如果遇到 JS 脚本和外部 JS 连接</p>
<p>会停止构建 DOM 树来执行和下载 相应的代码，这会造成阻塞</p>
<p>这就是为什么</p>
<h6 id="JS-代码应该放在-html-代码的后面"><a href="#JS-代码应该放在-html-代码的后面" class="headerlink" title="JS 代码应该放在 html 代码的后面"></a>JS 代码应该放在 html 代码的后面</h6><p>根据渲染出的DOM树和css合并为<strong>渲染树</strong></p>
<p>之后进行<strong>布局</strong>计算出每个节点在屏幕中的位置</p>
<p><strong>遍历render树</strong>，并绘制每个节点</p>
<h5 id="六、加载-JavaScript-脚本"><a href="#六、加载-JavaScript-脚本" class="headerlink" title="六、加载 JavaScript 脚本"></a>六、加载 JavaScript 脚本</h5><p>HTML\CSS 与 JS 是通过不同的引擎加载，但是却是<strong>互斥</strong>的，即加载 HTML\CSS 时，JS 会停止加载，相反亦然，这是因为 JS 引擎可以操作 DOM，改变样式、内容等。所以当执行了 JS 之后，渲染树要<strong>重新构建</strong></p>
<p>此时，页面加载出来</p>
<p>并发生一次</p>
<h4 id="重绘与回流"><a href="#重绘与回流" class="headerlink" title="重绘与回流"></a>重绘与回流</h4><p>此次<strong>回流</strong>是开销最大的一次</p>
<p>另外</p>
<p><strong>回流必定发生重绘</strong></p>
<p><strong>影响到页面布局的变化</strong>都会发生<strong>回流</strong></p>
<p><strong>不影响到页面布局</strong>的变化则是<strong>重绘</strong></p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h4><p>1.<strong>减少HTTP请求，合并js，css 合理内嵌js css</strong></p>
<p>2.<strong>合理设置服务器缓存，提高处理速度</strong></p>
<p>3.域名分片，资源放到不同的域名下，同一个域名最多处理6个TCP链接</p>
<p>4.加载数据优先级：preload(预先请求当前页面需要的资源) prefetch（将来页面中使用的资源），将数据缓存到HTTP缓存中</p>
<h4 id="渲染路径优化"><a href="#渲染路径优化" class="headerlink" title="渲染路径优化"></a>渲染路径优化</h4><ol>
<li>JavaScript强制将计算样式和布局操作提前 （例：load中）</li>
<li>减少发生重绘与回流</li>
</ol>
<h4 id="静态文件优化"><a href="#静态文件优化" class="headerlink" title="静态文件优化"></a>静态文件优化</h4><h5 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h5><h6 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h6><table>
<thead>
<tr>
<th>格式</th>
<th>适合场景</th>
<th>不适合</th>
</tr>
</thead>
<tbody><tr>
<td>jpg</td>
<td>色彩丰富的照片、banner图</td>
<td>图形文字、图标（纹理有锯齿），不支持透明</td>
</tr>
<tr>
<td>png</td>
<td>纯色、透明、图标、支持半透明</td>
<td>色彩丰富图片，因为无损储存会导致储存体积大</td>
</tr>
<tr>
<td>webp</td>
<td>适合半透明图片，可以保证图片质量和较小的体积</td>
<td></td>
</tr>
<tr>
<td>gif</td>
<td>动画，可以动的图标</td>
<td>不支持半透明，不适合存储彩色图片</td>
</tr>
<tr>
<td>svg</td>
<td>比jpg和png,它的体积更小适合小且色彩单一的图标</td>
<td>渲染成本过高</td>
</tr>
</tbody></table>
<h6 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h6><p>1.避免空src的图片</p>
<p>2.减小图片尺寸，节约用户流量</p>
<p>3.img标签设置alt属性，提升图片加载失败时的用户体验</p>
<p>4.原生的loading:lazy图片懒加载</p>
<p>5.不同环境下，加载不同尺寸和像素的图片</p>
<p>6.较大的图片可以考虑采用渐进式图片 </p>
<p>7.采用base64URL 减少图片请求</p>
<p>8.雪碧图合并图标图片 </p>
<h5 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h5><p> 1.减少HTML嵌套关系，减少DOM节点 </p>
<p> 2.删除多余空格，空行、注释、及无用的属性 </p>
<h5 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h5><p>1.减少伪类选择器，减少样式层数，减少使用通配符</p>
<p>2.避免使用css表达式  会频繁求值 </p>
<p>3.使用外链css,可以对css进行缓存</p>
<p>4.添加媒体字段，只加载有效的css 文件</p>
<h5 id="js"><a href="#js" class="headerlink" title="js"></a>js</h5><p>1.减少DOM操作，缓存访问过的元素</p>
<p>2.事件委托，减少事件绑定个数 </p>
<p>3.使用canvas动画、css动画 代替 js动画</p>
]]></content>
      <categories>
        <category>优化</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>14.coookie localStorage SessionStorage</title>
    <url>/2022/04/15/14-coookie-localStorage-SessionStorage/</url>
    <content><![CDATA[<h3 id="客户端存储"><a href="#客户端存储" class="headerlink" title="客户端存储"></a>客户端存储</h3><p><strong>cookie</strong>	<strong>WebStorage</strong>(H5)</p>
<p>WebStorage又可分为<strong>sessionStorage</strong>和<strong>localStorage</strong></p>
<h4 id="相同"><a href="#相同" class="headerlink" title="相同"></a>相同</h4><p>都可在本地存储</p>
<h4 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h4><h5 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h5><p>大小受限，每次新页面请求会发送cookie需指定作用域，可设过期时间，不可跨域调用</p>
<p>大小4k左右 一个页面最多20个</p>
<h5 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h5><p>只在同一会话才能访问，当网页关闭数据也销毁</p>
<h5 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h5><p>持久的本地化存储，除非主动删除。否则数据永不过期</p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="cookie-1"><a href="#cookie-1" class="headerlink" title="cookie"></a>cookie</h4><p>以</p>
<p><strong>名&#x3D;值</strong></p>
<p>的形式存储</p>
<h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.cookie = &quot;user=张三&quot;</span><br></pre></td></tr></table></figure>

<h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><p>直接重新创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.cookie = &quot;user=李四&quot;</span><br></pre></td></tr></table></figure>

<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>将值赋空</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.cookie = &quot;username=;&quot;</span><br></pre></td></tr></table></figure>

<h6 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h6><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>必选，cookie名</td>
</tr>
<tr>
<td>value</td>
<td>必选，cookie值</td>
</tr>
<tr>
<td>expire</td>
<td>可选，有效期</td>
</tr>
<tr>
<td>path</td>
<td>可选，生效路径</td>
</tr>
<tr>
<td>domain</td>
<td>可选，规定ckkoie域名</td>
</tr>
<tr>
<td>serure</td>
<td>可选，规定是否通过HTTPS传输</td>
</tr>
</tbody></table>
<h4 id="sessionStorage-localStorage"><a href="#sessionStorage-localStorage" class="headerlink" title="sessionStorage 	localStorage"></a>sessionStorage 	localStorage</h4><p>Web Storage API 继承于Window 对象,并提供两个新属性 — Window.sessionStorage 和 Window.localStorage </p>
<p><strong>只能存储字符串类型的对象</strong> </p>
<p>可用JSON对象的<strong>parse</strong> 和 <strong>stringify</strong>储存提取对象</p>
<h5 id="存"><a href="#存" class="headerlink" title="存"></a>存</h5><p>setitem</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj = &#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:&quot;18&quot;&#125;</span><br><span class="line"></span><br><span class="line">localStronge.setitem(&quot;user&quot;,JSON.stringify(obj))</span><br></pre></td></tr></table></figure>

<h5 id="取"><a href="#取" class="headerlink" title="取"></a>取</h5><p>getItem</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var userinfo = JSON.parse(localStorage.getItem(&quot;user&quot;))</span><br></pre></td></tr></table></figure>

<h5 id="删"><a href="#删" class="headerlink" title="删"></a>删</h5><p>remove</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">localStorage.remove(&quot;user&quot;)</span><br></pre></td></tr></table></figure>

<h5 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h5><p>clear</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">localStorage.clear();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>15.cookie 与token</title>
    <url>/2022/04/16/15-cookie-%E4%B8%8Etoken/</url>
    <content><![CDATA[<h3 id="为什么需要token-cookie"><a href="#为什么需要token-cookie" class="headerlink" title="为什么需要token cookie"></a>为什么需要token cookie</h3><p> HTTP协议本身是无状态的，所以需要一个标志来对用户进行<strong>身份验证</strong> </p>
<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p>用户登录成功后  后端生成一个<strong>sessionid</strong>放在<strong>cookie</strong>中返回给客户端，并且服务端一直记录着这个sessionid </p>
<p>用户再进行请求操作时，需要带上cookie，在服务器进行验证 </p>
<p>cookie是有状态的 </p>
<h4 id="token"><a href="#token" class="headerlink" title="token"></a>token</h4><p> 登陆后，后端会返回一个token给客户端，客户端将这个token存储起来 </p>
<p> 每次客户端请求都需要手动将token放在header中带过去 </p>
<p> 服务端每次只需要对这个token进行验证 </p>
<p> token是无状态的  </p>
<h5 id="相较于cookie"><a href="#相较于cookie" class="headerlink" title="相较于cookie"></a>相较于cookie</h5><p>1.支持跨域访问 ，将token置于请求头 </p>
<p>2.服务端无需存储token ，只需要验证token信息 </p>
<p>( session需要在服务端存储，一般是通过cookie中的sessionID在服务端查找对应的session )</p>
<p>3.避免<strong>CSRF</strong>跨站伪造攻击 </p>
<h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><p>跨站请求攻击</p>
<p><strong>原理</strong></p>
<p>利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出 </p>
<p>csrf并<strong>不能</strong>够<strong>拿到用户的任何信息</strong>，它只是<strong>欺骗用户浏览器</strong>，让其<strong>以用户的名义进行操作</strong> </p>
<p><strong>过程</strong></p>
<p> 攻击者通过  欺骗用户的浏览器去访问一个自己曾经认证过的网站 </p>
<p> 由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行 </p>
<p>利用cookie</p>
<p> cookie未失效，发起请求，浏览器自动携带cookie，后端以为是用户操作，于是进行操作 </p>
<p>无法利用token</p>
<p> 浏览器不会自动带上token，即使发了请求，后端的token验证不通过，不会进行操作 </p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>18.冒泡 捕获 事件委托 默认行为</title>
    <url>/2022/04/16/18-%E5%86%92%E6%B3%A1-%E6%8D%95%E8%8E%B7-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98-%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA/</url>
    <content><![CDATA[<h3 id="冒泡与捕获"><a href="#冒泡与捕获" class="headerlink" title="冒泡与捕获"></a>冒泡与捕获</h3><h4 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h4><p>从内层往父级层层往上，往上传递的行为</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">给wrap middle center各加上点击事件并打印自己的类名</span><br><span class="line"></span><br><span class="line">点击wrap打印wrap</span><br><span class="line">点击middle先打印middle后打印wrap</span><br><span class="line">点击center打印 center middle wrap</span><br></pre></td></tr></table></figure>

<p>由此见</p>
<p><strong>浏览器默认是冒泡</strong></p>
<h5 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">center.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    e.<span class="title function_">stopPropagation</span>()		<span class="comment">//阻止冒泡</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;center&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////</span></span><br><span class="line">冒泡兼容处理</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">stopPro</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> oEv = e ||event;</span><br><span class="line">    <span class="keyword">if</span>(oEv.<span class="property">stopPropagation</span>)&#123;</span><br><span class="line">    	oEv.<span class="title function_">stopPropagation</span>();<span class="comment">//非IE浏览器</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        oEv.<span class="property">cancelBubble</span> = <span class="literal">true</span>;<span class="comment">//IE浏览器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终</span></span><br><span class="line">center.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="title function_">stopPro</span>(e)	<span class="comment">//阻止冒泡</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;center&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="利用冒泡进行事件委托addEventListener（）"><a href="#利用冒泡进行事件委托addEventListener（）" class="headerlink" title="利用冒泡进行事件委托addEventListener（）"></a>利用冒泡进行事件委托addEventListener（）</h5><p><strong>定义</strong></p>
<p>利用冒泡的原理把<strong>事件绑定给父级或祖先，操作子级，触发事件</strong></p>
<p>addEventListener()有三个参数</p>
<p>参数1：监听事件类型</p>
<p>参数2：执行回调</p>
<p>参数3：监听冒泡是捕获 (true冒泡，false捕获)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">点击li触发回调</span><br><span class="line"><span class="comment">//循环绑定</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; li.<span class="property">length</span>;i++)&#123;</span><br><span class="line">	<span class="title function_">addEventHandeler</span>(li[i],<span class="string">&quot;click&quot;</span>,conIner)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">conIner</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">innerHTML</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h4><p>从外层往子级传播</p>
<h4 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h4><p>定义</p>
<p>浏览器自己执行的行为，比如邮件弹出菜单</p>
<p><strong>阻止方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.函数最后一行写 return false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.event对象proeventDefault()</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">oncontextmenu</span> = <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="comment">// alert(1);</span></span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    <span class="comment">// return false;</span></span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">var</span> oEv = e || oEv;</span><br><span class="line">    oEv.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>16.HTTP与HTTPS</title>
    <url>/2022/04/16/16-HTTP%E4%B8%8EHTTPS/</url>
    <content><![CDATA[<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>是应用最广泛的网络协议</p>
<p><strong>作用</strong></p>
<p>用于从WWW服务器<strong>传输超文本</strong>到本地浏览器的<strong>传输协议</strong>   <strong>明文传输</strong>，它可以使浏览器更加高效，使网络传输减少 </p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p> HTTP的安全版 </p>
<p> HTTP下加入<strong>SSL</strong>层 进行 <strong>加密</strong> </p>
<p><strong>作用</strong></p>
<p> 建立一个信息安全通道 </p>
<p> 确认网站的真实性 </p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>1.https协议<strong>需要到ca申请证书</strong>  需要一定费用 </p>
<p>2.http是超文本传输协议，信息是<strong>明文传输</strong>，https则是具有安全性的ssl<strong>加密传输</strong>协议 </p>
<p>3.端口也不一样，http是80，后者是443 </p>
<p>4.http的连接简单，无状态 	 HTTPS  是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，更安全 </p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>17.原型与原型链</title>
    <url>/2022/04/16/17-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h3 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h3><p>早期js没有继承机制</p>
<p>构造函数内部的属性方法，每次new一个实例对象的时候，都会创建内部的这些属性和方法，并且不同的实例对象之间，不能共享这些方法，造成了资源的浪费 </p>
<p> 为了将所有的对象关联 	 原型 </p>
<p>引入了new关键字 和 constructor构造函数来简化对象的设计</p>
<p>引入了<strong>prototype函数对象</strong>来<strong>包含所有实例对象的构造函数的属性和方法</strong></p>
<p>引入了<strong>proto原型</strong>和<strong>原型链</strong>的概念<strong>解决继承</strong>的问题 </p>
<h3 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h3><p>所有<strong>引用类型</strong>都有**<code>__proto__</code>隐式原型**属性</p>
<p>所有<strong>函数</strong>都有<strong>prototype显式原型</strong>属性</p>
<p>理解<strong>实例继承构造函数</strong>的方法和属性 </p>
<p><strong>实例的隐式原型指向它构造函数的显示原型</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;张三&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setSex</span> = <span class="keyword">function</span>(<span class="params">sex</span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">sex</span> = sex</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Man</span> = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>)				<span class="comment">//①</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Man</span>)				<span class="comment">//②</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Man</span>.<span class="property">name</span>)			<span class="comment">//③</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Man</span>.<span class="property">age</span>)			<span class="comment">//④</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Man</span>.<span class="property">setSex</span>)			<span class="comment">//⑤</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)	<span class="comment">//⑥</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Man</span>.<span class="property">__proto__</span>)		<span class="comment">//⑦</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line">①</span><br><span class="line">ƒ <span class="title class_">Person</span>()&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;张三&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">②</span><br><span class="line"><span class="title class_">Person</span> &#123;<span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>&#125;</span><br><span class="line">③</span><br><span class="line">张三</span><br><span class="line">④</span><br><span class="line"><span class="number">18</span></span><br><span class="line">⑤</span><br><span class="line">ƒ (sex)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">sex</span> = sex</span><br><span class="line">&#125;</span><br><span class="line">⑥</span><br><span class="line">&#123;<span class="attr">age</span>: <span class="number">18</span>, <span class="attr">setSex</span>: ƒ, <span class="attr">constructor</span>: ƒ&#125;</span><br><span class="line">⑦</span><br><span class="line">&#123;<span class="attr">age</span>: <span class="number">18</span>, <span class="attr">setSex</span>: ƒ, <span class="attr">constructor</span>: ƒ&#125;</span><br></pre></td></tr></table></figure>



<h4 id="原型的使用"><a href="#原型的使用" class="headerlink" title="原型的使用"></a>原型的使用</h4><p><strong>构造函数创建的实例可以访问构造函数的属性和方法，也可以访问原型的属性和方法</strong> </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span>= <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">setName</span>= <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setAge</span> =<span class="keyword">function</span>(<span class="params">age</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(man.<span class="property">name</span>)			<span class="comment">//①</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(man.<span class="property">__proto__</span>)		<span class="comment">//②</span></span><br><span class="line"></span><br><span class="line">①</span><br><span class="line">张三</span><br><span class="line">②</span><br><span class="line">&#123;<span class="attr">setAge</span>: ƒ, <span class="attr">constructor</span>: ƒ&#125;</span><br></pre></td></tr></table></figure>



<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>对象访问属性和方法的时候，会往自身查找，如果没有才会去原型中找。（一级一级传递 形成了原型链） </p>
<p>原型链的本质：建立对象之间的关联 实现继承</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>19.作用域 变量</title>
    <url>/2022/04/16/19-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><p>一个Script标签就是一个<strong>全局作用域</strong></p>
<p>全局作用域可访问<strong>自身</strong>作用域的函数和变量</p>
<h4 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h4><p> 一个函数就是一个局部作用域 </p>
<p>局部作用域 可访问<strong>全局作用域和自身</strong>的函数和变量</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="声明方式"><a href="#声明方式" class="headerlink" title="声明方式"></a>声明方式</h4><p><strong>var let const</strong></p>
<p>只有var与window相映射</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> c =<span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">a</span>)		<span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">b</span>)		<span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">c</span>)		<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>



<h6 id="var"><a href="#var" class="headerlink" title="var"></a>var</h6><p>全局声明</p>
<p>可重复声明，后者替换前者</p>
<p>存在变量提升——未声明调用为undefined</p>
<h6 id="let"><a href="#let" class="headerlink" title="let"></a>let</h6><p>块级作用域有效</p>
<p><strong>暂时性死区</strong>：会绑定在块级作用域，不受外界影响</p>
<p>不可重复声明</p>
<h6 id="const是常量"><a href="#const是常量" class="headerlink" title="const是常量"></a>const是常量</h6><p>块级作用域有效</p>
<p>不可重复声明</p>
<p>const声明的常量的是一个只读的常量，声明后不能更改，const保证的不是常量的值不改变，而是常量指向的那个内存地址的数据不被改变</p>
<p> const定义的基本类型不能改变，但是定义的队形是可以通过修改对象属性等方法来改变 </p>
<h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a><strong>全局变量</strong></h5><p>全局作用域下定义的变量</p>
<h6 id="全局作用域访问全局变量"><a href="#全局作用域访问全局变量" class="headerlink" title="全局作用域访问全局变量"></a>全局作用域访问全局变量</h6><h6 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h6><p>内部函数访问外部函数的变量时候，采用的是链式查找的方式来决定取哪个值。【就近原则】 </p>
<p><strong>var</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//变量提升（暂时性死区）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)		<span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;			</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;			<span class="comment">//可以覆盖</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)		<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)	<span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun1</span>()				</span><br><span class="line"></span><br><span class="line"><span class="comment">//作用域链	【就近原则】</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)	<span class="comment">//undefined</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)	<span class="comment">//3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun2</span>()				</span><br></pre></td></tr></table></figure>

<p><strong>let</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// console.log(a)	//let声明前不可调用</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">a =<span class="number">2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"><span class="comment">// let a = 3		//let声明变量后不可重复声明</span></span><br></pre></td></tr></table></figure>

<p><strong>const</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// console.log(a)	//const声明前不可调用</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"><span class="comment">// a =2				//const声明前不可直接更改</span></span><br><span class="line"><span class="comment">// const a = 3		//const声明变量后不可重复声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>&#125;;</span><br><span class="line">obj[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">obj.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123;name: &quot;李四&quot;, age: 18&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>const定义的基本类型不能改变，但是定义的引用类型中的 数组 与 对象 可以通过修改对象属性改变</strong> </p>
<h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>局部作用域下定义的变量</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>20.创建对象的方法</title>
    <url>/2022/04/16/20-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="1-字面量"><a href="#1-字面量" class="headerlink" title="1.字面量"></a>1.字面量</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">	<span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-new-Object"><a href="#2-new-Object" class="headerlink" title="2.new Object"></a>2.new Object</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&quot;张三&quot;</span></span><br><span class="line">obj.<span class="property">fun</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	onsole.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-工厂模式"><a href="#3-工厂模式" class="headerlink" title="3.工厂模式"></a>3.工厂模式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">    obj.<span class="property">name</span>=name;</span><br><span class="line">    obj.<span class="property">fun</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>函数名<strong>小写</strong>，<strong>调用系统构造函数Object</strong>创建对象，为对象添加属性或方法后<strong>返回</strong>，直接调用<strong>函数创建对象</strong> </p>
<h3 id="4-构造函数"><a href="#4-构造函数" class="headerlink" title="4.构造函数"></a>4.构造函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fun</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>首字母大写</strong>，<strong>this是当前对象</strong>，通过<strong>new的方式来创建</strong>对象 </p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>21.ES6新增(01)</title>
    <url>/2022/04/17/21-ES6%E6%96%B0%E5%A2%9E/</url>
    <content><![CDATA[<p>常用新增</p>
<p>let	const</p>
<p>变量的解构赋值</p>
<p>Symbol原始数据类型</p>
<p>Set和Map类型</p>
<p>Class类</p>
<p>Promise对象</p>
<p>async对象</p>
<p>Proxy代理</p>
<h3 id="1-新增变量声明"><a href="#1-新增变量声明" class="headerlink" title="1.新增变量声明"></a>1.新增变量声明</h3><h4 id="let-const"><a href="#let-const" class="headerlink" title="let const"></a>let const</h4><p><strong>共同点</strong></p>
<p>1.不存在变量提升</p>
<p>2.不可重复命名</p>
<p>3.只在当前块级作用域使用</p>
<p><strong>不同点</strong></p>
<p>1.let 允许先声明后赋值 const不允许</p>
<p>2.const声明变量不能被修改但声明的数组和对象可以修改</p>
<p>因此，不推荐用const声明引用类型</p>
<h3 id="2-新增原始数据类型"><a href="#2-新增原始数据类型" class="headerlink" title="2.新增原始数据类型"></a>2.新增原始数据类型</h3><h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><p> 保证每个属性名独一无二，防止属性名的冲突 </p>
<p> Symbol 值通过**<code>Symbol()</code>函数**生成 </p>
<p> <strong>对象的属性名</strong>现在可以有<strong>两种类型</strong>，一种是<strong>字符串</strong>，另一种 <strong>Symbol 类型</strong> </p>
<p> <code>Symbol</code>函数前<strong>不能使用<code>new</code>命令</strong>，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象 </p>
<p> <code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此<strong>相同参数的<code>Symbol</code>函数的返回值是不相等</strong> </p>
<h5 id="作为对象的属性"><a href="#作为对象的属性" class="headerlink" title="作为对象的属性"></a>作为对象的属性</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="title class_">Symbol</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 写法1</span></span><br><span class="line"><span class="keyword">let</span> syObject = &#123;&#125;;</span><br><span class="line">syObject[sy] = <span class="string">&quot;symbol&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(syObject);    <span class="comment">// &#123;Symbol(): &quot;symbol&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 写法2</span></span><br><span class="line"><span class="keyword">let</span> syObject = &#123;</span><br><span class="line">  [sy]: <span class="string">&quot;symbol&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(syObject);    <span class="comment">// &#123;Symbol(): &quot;symbol&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 写法3</span></span><br><span class="line"><span class="keyword">let</span> syObject = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(syObject, sy, &#123;<span class="attr">value</span>: <span class="string">&quot;symbol&quot;</span>&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(syObject);   <span class="comment">// &#123;Symbol(): &quot;symbol&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能用点</span></span><br><span class="line">syObject[sy];  <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line">syObject.<span class="property">sy</span>;   <span class="comment">// undefined </span></span><br><span class="line"><span class="comment">// syObject.sy ==&gt; syObject[&quot;sy&quot;]</span></span><br></pre></td></tr></table></figure>



<h3 id="3-解构赋值"><a href="#3-解构赋值" class="headerlink" title="3.解构赋值"></a>3.解构赋值</h3><p><strong>定义</strong></p>
<p>从数组和对象提取值，对变量赋值</p>
<p><strong>表达式的组成</strong></p>
<p>目标	&#x3D;	来源</p>
<h4 id="解构数组"><a href="#解构数组" class="headerlink" title="解构数组"></a>解构数组</h4><p><strong>有次序</strong></p>
<p>示例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//以上分别声明三个变量并赋值</span></span><br><span class="line"><span class="comment">//用解构赋值的写法则为</span></span><br><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p><strong>可嵌套</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,[b,c],d] = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>]</span><br><span class="line"><span class="comment">//a	1</span></span><br><span class="line"><span class="comment">//b	2</span></span><br><span class="line"><span class="comment">//c	3</span></span><br><span class="line"><span class="comment">//d	4</span></span><br></pre></td></tr></table></figure>

<p><strong>可忽略</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">//a 1</span></span><br><span class="line"><span class="comment">//c	3</span></span><br></pre></td></tr></table></figure>

<p><strong>可覆盖</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">5</span>,,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">//a 1</span></span><br><span class="line"><span class="comment">//c	3</span></span><br></pre></td></tr></table></figure>

<p><strong>不完全解构</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>, b] = []; </span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>值为[] undefined null</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b] = [];</span><br><span class="line"><span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">let</span> [a,b] = [<span class="literal">undefined</span>];</span><br><span class="line"><span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">let</span> [a=<span class="number">1</span>] = [<span class="literal">undefined</span>]</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>,b] = [<span class="literal">null</span>]</span><br><span class="line"><span class="comment">//null</span></span><br></pre></td></tr></table></figure>

<p><strong>可使用剩余运算符</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">//a = 1</span></span><br><span class="line"><span class="comment">//b = [2, 3]</span></span><br><span class="line"><span class="comment">//剩余运算符只能放最后</span></span><br></pre></td></tr></table></figure>

<p><strong>若变量为数组</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>]</span><br><span class="line"><span class="comment">//a	1</span></span><br><span class="line"><span class="comment">//b	[2,3]</span></span><br><span class="line"><span class="comment">//c	4</span></span><br></pre></td></tr></table></figure>

<h5 id="不可解构"><a href="#不可解构" class="headerlink" title="不可解构"></a>不可解构</h5><p><strong>不能遍历的结构不能被解构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let [a] = 1</span><br></pre></td></tr></table></figure>





<h4 id="解构对象"><a href="#解构对象" class="headerlink" title="解构对象"></a>解构对象</h4><p><strong>没有次序</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;name,age&#125; = &#123;<span class="attr">age</span>:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>&#125;</span><br><span class="line"><span class="comment">// name = &quot;张三&quot;</span></span><br><span class="line"><span class="comment">// age = 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//name是name:name</span></span><br><span class="line"><span class="comment">//ES6新特性规定对象的属性和值用同一变量可以简写为一个</span></span><br></pre></td></tr></table></figure>

<h5 id="已经声明的变量用于解构赋值"><a href="#已经声明的变量用于解构赋值" class="headerlink" title="已经声明的变量用于解构赋值"></a>已经声明的变量用于解构赋值</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexpected token &#x27;=&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>变量名与属性不一致</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span>: baz&#125; = &#123;<span class="attr">foo</span>:<span class="string">&quot;a&quot;</span>,<span class="attr">bar</span>: <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line"><span class="comment">//baz ——&gt; a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是因为解构赋值的内部机制是先找同名属性，再赋值给变量</span></span><br><span class="line"><span class="comment">//真正被赋值的是后者baz</span></span><br></pre></td></tr></table></figure>





<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><h6 id="1-任意个参数求和"><a href="#1-任意个参数求和" class="headerlink" title="1.任意个参数求和"></a>1.任意个参数求和</h6><p>传统方法：   js传统方法需要借助arguments来实现，具体方法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> len = <span class="variable language_">arguments</span>.<span class="property">length</span>; <span class="comment">// 将长度存储在变量中可以减少循环次数，提升性能</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">    sum +=<span class="variable language_">arguments</span>[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);  <span class="comment">// 6</span></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;4&quot;</span>); <span class="comment">// &quot;34&quot;</span></span><br><span class="line">此处只是为了对比传统方法和<span class="title class_">ES6</span>新方法求和，未作数值类型转化，故第二个调用出现了字符串拼接</span><br></pre></td></tr></table></figure>

<p>ES6新方法：   ES6用剩余项表达式和解构来存储参数个数，求和的方法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">...nums</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">x,y</span>)=&gt;</span>&#123;<span class="keyword">return</span> x+y&#125;)</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);  <span class="comment">// 6</span></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;4&quot;</span>); <span class="comment">// &quot;34&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>注意此处使用了ES6数组的新方法：reduce，reduce的作用是汇总，输入一堆，输出一个结果</code>   在这里我们可能感觉两种方法的实现原理好像是一样的额，其实并不然，传统方法借助的arguments是一个类数组，虽然我们可以像数组一样用下标，即<code>arguments[0],arguments[1]</code>,…的方式去访问它，也能通过<code>arguments.length</code>来计算传入参数的个数，还能使用<code>arguments.callee</code>(注意在ES5中这个属性已被废弃，<code>caller</code>不是的属性)，然而它还是没有数组常用的一些方法，比如<code>reduce,pop,push,shift,unshift</code>等，所以用传统方法求参数和要比ES6的代码多好几行。</p>
<h6 id="2-不借助第三个参数交换变量的值"><a href="#2-不借助第三个参数交换变量的值" class="headerlink" title="2.不借助第三个参数交换变量的值"></a>2.不借助第三个参数交换变量的值</h6><p>传统方法：   传统方法（ES6之前，C语言等）要交换两个变量的值需要借助第三个变量，在js中的实现方法大概如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b,c);</span><br><span class="line">a = b;</span><br><span class="line">b = c;</span><br><span class="line"><span class="comment">// a = 2;</span></span><br><span class="line"><span class="comment">// b = 1;</span></span><br><span class="line"><span class="comment">// c = 1;</span></span><br></pre></td></tr></table></figure>

<p>所以，传统方法大概需要5行代码才能实现。</p>
<p>ES6方法： ES6中我们不需要借助第三个参数，具体实现方法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">[a, b] = [b, a];</span><br><span class="line"><span class="comment">// a = 2;</span></span><br><span class="line"><span class="comment">// b = 1;</span></span><br></pre></td></tr></table></figure>

<p>从上面可以看出我们只需要三行代码就能完成参数的交换。</p>
<h6 id="3-收集函数的剩余参数-用作公共函数可选项"><a href="#3-收集函数的剩余参数-用作公共函数可选项" class="headerlink" title="3.收集函数的剩余参数,用作公共函数可选项"></a>3.收集函数的剩余参数,用作公共函数可选项</h6><p>  我们都知道js中传递的实参可以不和形参一一对应；   形参个数大于实参个数时，多余的形参会被初始化为<code>undefined</code>(函数声明整体提升，随后找形参并将形参初始化为undefined，最后才是实参和形参相统一，所以没有实参对应的形参值仍然是undefined)；   当形参个数小于实参个数时，多余的实参会被忽略；   因此，一些场景下即使我们只用到一次的或者可能不会用到的参数都要在定义形参来传递，一些参数个数不确定的场景下我们只能通过多定义形参来解决问题，但是这显然有些笨拙。   在ES6新特性中，我们可以通过“…+变量名”来解决参数传递的问题。   下面我们可以通过函数来简单模范api的可选参数，我们把必填参数放在前面，把可选参数放在剩余项里，这样我们的代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dateFormat</span>(<span class="params">a,..b</span>)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  上面代码a是必填参数，b是可选参数的集合，这样我们就能通过一个变量将不常用的参数放到一个集合中了。</p>
<h6 id="4-返回多个函数结果"><a href="#4-返回多个函数结果" class="headerlink" title="4.返回多个函数结果"></a>4.返回多个函数结果</h6><p>  ES6之前我们想从函数返回多个结果，只能将它们放在数组或对象里返回，想要获取每一个返回结果，少不了循环和遍历语句，这很让人头疼。   有了ES6后我们就可以将函数执行的结果一个一个的提取出来。大概的代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = <span class="title function_">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = <span class="title function_">test</span>();</span><br></pre></td></tr></table></figure>

<h6 id="5-简化底层数据的调用"><a href="#5-简化底层数据的调用" class="headerlink" title="5.简化底层数据的调用"></a>5.简化底层数据的调用</h6><p>  很多时候后台返回给我们的都是一些对象和数组的混合嵌套体，对于深层数据的访问我们往往需要写一长串“.”引用，用解构赋值我们就可以将这些数据单独获取出来。</p>
<h6 id="6-设置函数参数的默认值"><a href="#6-设置函数参数的默认值" class="headerlink" title="6.设置函数参数的默认值"></a>6.设置函数参数的默认值</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jQuery.<span class="property">ajax</span> = <span class="keyword">function</span> (<span class="params">url, &#123;</span></span><br><span class="line"><span class="params">  <span class="keyword">async</span> = <span class="literal">true</span>,</span></span><br><span class="line"><span class="params">  beforeSend = <span class="keyword">function</span> () &#123;&#125;,</span></span><br><span class="line"><span class="params">  cache = <span class="literal">true</span>,</span></span><br><span class="line"><span class="params">  complete = <span class="keyword">function</span> () &#123;&#125;,</span></span><br><span class="line"><span class="params">  crossDomain = <span class="literal">false</span>,</span></span><br><span class="line"><span class="params">  <span class="variable language_">global</span> = <span class="literal">true</span>,</span></span><br><span class="line"><span class="params">  // ... more config</span></span><br><span class="line"><span class="params">&#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。</p>
<h6 id="7-遍历-Map-结构"><a href="#7-遍历-Map-结构" class="headerlink" title="7.遍历 Map 结构"></a>7.遍历 Map 结构</h6><p>任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&quot; is &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure>

<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="8-输入模块的指定方法"><a href="#8-输入模块的指定方法" class="headerlink" title="8.输入模块的指定方法"></a>8.输入模块的指定方法</h6><p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">SourceMapConsumer</span>, <span class="title class_">SourceNode</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;source-map&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="4-字符串模板"><a href="#4-字符串模板" class="headerlink" title="4.字符串模板"></a>4.字符串模板</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = &#x27;hello&#x27;</span><br><span class="line">var b = `$&#123;a&#125; world!`</span><br><span class="line">console.log(b);</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>22.ES6新增(02)</title>
    <url>/2022/04/17/22-ES6%E6%96%B0%E5%A2%9E-02/</url>
    <content><![CDATA[<h3 id="Promiseasyncawait"><a href="#Promiseasyncawait" class="headerlink" title="Promise	async	await"></a>Promise	async	await</h3><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>用途：解决<strong>回调地狱</strong></p>
<p>回调地狱：回调函数层层嵌套</p>
<p><strong>本质</strong></p>
<p>1.异步编程的解决方案</p>
<p>2.是一个容器，内部保存未来才会结束的事件的结果</p>
<p>3.本身是构造函数，new Promise()是Promise对象，来获取异步操作消息</p>
<p>4.提供API，处理各种异步操作</p>
<h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve,reject</span>)&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Promise 新建后就会立即执行</span></span><br><span class="line"><span class="comment">//成功调用resolve	失败调用reject</span></span><br></pre></td></tr></table></figure>

<p>具有<strong>三种状态</strong></p>
<p><strong>pending</strong>	进行中</p>
<p><strong>fulfiled</strong>		已成功</p>
<p><strong>rejected</strong>		已失败</p>
<p>只有异步操作的结果，可以决定当前是哪一种状态 </p>
<p>无法取消Promise，一旦创建，立即执行</p>
<p>如果不设置回调，promise内部的错误不会反应到外部</p>
<p>处于pending状态时，无法得知进展到那个阶段</p>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><table>
<thead>
<tr>
<th>方法</th>
<th>类型</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>then</td>
<td>原型方法</td>
<td>为实例添加状态改变时的回调</td>
</tr>
<tr>
<td>catch</td>
<td>原型方法</td>
<td>发生错误时的回调</td>
</tr>
<tr>
<td>finally</td>
<td>原型方法</td>
<td>不管如何都发生的回调</td>
</tr>
<tr>
<td>resolve</td>
<td>静态方法</td>
<td>Promise对象状态由padding转为fulfiled时执行的回调</td>
</tr>
<tr>
<td>reject</td>
<td>静态方法</td>
<td>Promise对象状态由padding转为rejected时执行的回调</td>
</tr>
<tr>
<td>all</td>
<td>静态方法</td>
<td>将多个Promise实例包装成一个新的Promise实例</td>
</tr>
<tr>
<td>race</td>
<td>静态方法</td>
<td>将多个Promise实例包装成一个新的Promise实例</td>
</tr>
<tr>
<td>allSettled</td>
<td>静态方法</td>
<td>将多个Promise实例包装成一个新的Promise实例</td>
</tr>
<tr>
<td>any</td>
<td>静态方法</td>
<td>将多个Promise实例包装成一个新的Promise实例返回</td>
</tr>
</tbody></table>
<h6 id="then-catch"><a href="#then-catch" class="headerlink" title="then catch"></a><strong>then</strong> catch</h6><p>promise的原型方法</p>
<p><strong>传参为两个函数</strong></p>
<p>第一个为成功执行的内容</p>
<p>第二个为<strong>失败执行</strong>的内容，一般省略，</p>
<p>需要时<strong>放在catch</strong>方法内(在then方法后 promise.then(…).catch(…))</p>
<p>then和catch调用时返回一个新Promise对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve,reject</span>)&#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">	&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//then可以渠道resolve和reject的参是因为rexolve华人reject传的参Promise内部进行了记录</span></span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(data)	<span class="comment">//success</span></span><br><span class="line">&#125;,<span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(err)	<span class="comment">//不执行</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;链式调用&quot;</span>+data)	<span class="comment">//链式调用 undefined</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h6 id="all"><a href="#all" class="headerlink" title="all"></a>all</h6><p>处理并发的异步操作，使它们的结果互不干扰，</p>
<p><strong>条件</strong></p>
<p>1.Promise.all()接收一个参数，必须是可迭代的</p>
<p>2.它的状态受参数内各个值的状态影响，全为fulfiled时，才为fulfiled</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//成功</span></span><br><span class="line"><span class="keyword">var</span> promises = arr.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>（resolve,reject)&#123;</span><br><span class="line">      <span class="title function_">resolve</span>(item * <span class="number">5</span>)  </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)	<span class="comment">//[5,10,15]</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//失败</span></span><br><span class="line"><span class="keyword">var</span> promises2 = arr.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>（resolve,reject)&#123;</span><br><span class="line">      <span class="keyword">if</span>(item === <span class="number">3</span>)&#123;</span><br><span class="line">          <span class="title function_">reject</span>(<span class="string">&#x27;reject&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="title function_">resolve</span>(item * <span class="number">5</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises2).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)	<span class="comment">//不执行</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(err)	<span class="comment">//reject</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h6 id="race"><a href="#race" class="headerlink" title="race"></a>race</h6><p><strong>条件</strong></p>
<p>1.Promise.race()接收一个参数，必须是可迭代的</p>
<p>2.它的状态受参数内执行最快的状态的影响</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve,reject</span>)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve,<span class="number">1000</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve,reject</span>)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve,<span class="number">50</span>,<span class="string">&quot;b&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve,reject</span>)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve,<span class="number">200</span>,<span class="string">&quot;c&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([a,b,c]).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)	<span class="comment">//b</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)	<span class="comment">//不执行</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>





<h4 id="asyncawait"><a href="#asyncawait" class="headerlink" title="async	await"></a>async	await</h4><h5 id="async"><a href="#async" class="headerlink" title="async"></a>async</h5><p>简化Promise的创建</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Promise</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pro</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve,<span class="number">1000</span>,<span class="string">&quot;pro&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">pro</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)		<span class="comment">//pro</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//async</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hellow&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//b</span></span><br><span class="line"><span class="comment">//hellow</span></span><br></pre></td></tr></table></figure>

<p><strong>async实现原理</strong></p>
<p>如果该函数有返回值，调用函数时，默认在内部调用Promise.resolve()</p>
<p>返回Promise对象</p>
<p>若函数内部抛出错误调用Promise.reject()</p>
<p>返回Promise对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function fun(flag)&#123;</span><br><span class="line">	if(flag)&#123;</span><br><span class="line">		return &quot;hellow&quot;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		throw new Error(&quot;error&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">error!!...</span><br><span class="line">console.log(fun(true))	//Promise&#123;&lt;resolved&gt;: &quot;hellow&quot;&#125;</span><br><span class="line">console.log(fun(false))	//Promise&#123;&lt;rejected&gt;: Error: error!!...&#125;</span><br></pre></td></tr></table></figure>



<h5 id="await"><a href="#await" class="headerlink" title="await"></a>await</h5><p><strong>相当于then</strong>方法，必须写在<strong>async里面</strong></p>
<p><strong>返回</strong>的不是Promise对象，而是<strong>处理之后的结果</strong></p>
<p>会暂停当前async的执行，等待Promise处理完成</p>
<p>若转为fulfiled，回调resolce函数参数作为await 表达式的值</p>
<p>继续执行async函数</p>
<p>若转为rejected，会把异常原因抛出，</p>
<p>如果await后的表达式的值不是Promise，该值会被转化为Promise</p>
<h4 id="对比Promise"><a href="#对比Promise" class="headerlink" title="对比Promise"></a>对比Promise</h4><p>不在需要多层.then()</p>
<p>如果一个业务需要多步完成，每个步骤都是异步，依赖上一步骤结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">pub</span>(<span class="params">n</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(n + <span class="number">100</span>),n)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params">n</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a&quot;</span> + n)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">pub</span>(n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params">n</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b&quot;</span> + n)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">pub</span>(n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">c</span>(<span class="params">n</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;c&quot;</span> + n)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">pub</span>(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Promise写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doIt</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&quot;doIt&quot;</span>)	<span class="comment">//查看代码运行效率</span></span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span></span><br><span class="line">    <span class="title function_">a</span>(time1).<span class="title function_">then</span>(<span class="function"><span class="params">time2</span> =&gt;</span> <span class="title function_">b</span>(time2))</span><br><span class="line">        	.<span class="title function_">then</span>(<span class="function"><span class="params">time3</span> =&gt;</span> <span class="title function_">b</span>(time3))</span><br><span class="line">    		.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&quot;doIt&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//async await写法</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">doIt</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&quot;doIt&quot;</span>)</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span></span><br><span class="line">    <span class="keyword">const</span> time2 = <span class="keyword">await</span> <span class="title function_">a</span>(time1)</span><br><span class="line">    <span class="keyword">const</span> time3 = <span class="keyword">await</span> <span class="title function_">b</span>(time2)</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">c</span>(time3)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&quot;doIt&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>23.定时器</title>
    <url>/2022/04/18/23-%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<h3 id="setTimeoutsetInterval"><a href="#setTimeoutsetInterval" class="headerlink" title="setTimeout	setInterval"></a>setTimeout	setInterval</h3><p>setTimeout(fun,time,val1,val)</p>
<p><strong>至少接受两个值</strong></p>
<p>第一个值为调用函数的函数名</p>
<p>第二个值为函数执行时间</p>
<p>其后的值都为函数的参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logNum</span>(<span class="params">n</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">setTimeout</span>(logNum,<span class="number">1000</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">setInterval</span>(logNum,<span class="number">1000</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除定时器</span></span><br><span class="line"><span class="comment">//clearTimeout(a)</span></span><br><span class="line"><span class="comment">//clearInterval(b)</span></span><br></pre></td></tr></table></figure>



<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>setTimeout()	为创建之后一段时间执行</p>
<p>clearInterval()	为每隔一段时间执行</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>24.ES6新增(03)</title>
    <url>/2022/04/18/24-ES6%E6%96%B0%E5%A2%9E03/</url>
    <content><![CDATA[<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;		<span class="comment">//匿名函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;&#125;	<span class="comment">//具名函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun2</span>(<span class="params">a,b</span>)&#123;&#125;	<span class="comment">//传参</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line">() =&gt; &#123;&#125;						<span class="comment">//匿名函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fun</span> = (<span class="params"></span>) =&gt; &#123;&#125;			<span class="comment">//具名函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fun2</span> = (<span class="params">a,b</span>) =&gt; &#123;&#125;		<span class="comment">//传参</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fun3</span> = a =&gt; &#123;&#125;			<span class="comment">//只有一个参可省略()</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fun4</span> = a =&gt; <span class="keyword">return</span> <span class="number">1</span>		<span class="comment">//函数体只有一句可省略&#123;&#125;</span></span><br></pre></td></tr></table></figure>



<p><strong>注意</strong></p>
<p>1.箭头函数this指向函数定义位置中作用域的this，不可更改</p>
<p>因此：箭头函数不可作为构造函数，不能使用new</p>
<p>2.箭头函数没有原型属性</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/04/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>关于hexo的操作</title>
    <url>/2022/04/11/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="hexo的基本操作"><a href="#hexo的基本操作" class="headerlink" title="hexo的基本操作"></a>hexo的基本操作</h2><span id="more"></span>

<p>我的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://surpass1004.github.io/</span><br></pre></td></tr></table></figure>



<h3 id="创建一个页面"><a href="#创建一个页面" class="headerlink" title="创建一个页面"></a>创建一个页面</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//新建一个标题为 name 的页面，默认链接地址为主页地址/name / </span><br><span class="line">hexo new/n page name 	</span><br><span class="line"></span><br><span class="line">//在生成的.md文件配置</span><br><span class="line">title: 与_config.yml文件中 meun 配置一致</span><br><span class="line">date: </span><br><span class="line">type: 与_config.yml文件中 meun 配置的值一致</span><br><span class="line">layout: 打开的页面，尽量与type一致</span><br></pre></td></tr></table></figure>



<h3 id="创建博客文章"><a href="#创建博客文章" class="headerlink" title="创建博客文章"></a>创建博客文章</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//清除所有记录 </span><br><span class="line">hexo clean	</span><br><span class="line"></span><br><span class="line">//新建一个标题为 name 的文章 在你的blog/source/_posts下 name .md</span><br><span class="line">hexo new/n &quot;name &quot; </span><br><span class="line"></span><br><span class="line">//生成静态网页  到默认设置的 public 文件夹 </span><br><span class="line">hexo generate/g		</span><br><span class="line"></span><br><span class="line">//生成静态网页   并部署到设定的仓库 </span><br><span class="line">hexo deploy/d 	</span><br><span class="line"></span><br><span class="line">//启动服务 </span><br><span class="line">hexo server/s 	</span><br></pre></td></tr></table></figure>



<h3 id="配置分类或标签"><a href="#配置分类或标签" class="headerlink" title="配置分类或标签"></a>配置分类或标签</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//标题</span><br><span class="line">tags: name</span><br><span class="line"></span><br><span class="line">//分类</span><br><span class="line">categories: namae</span><br><span class="line"></span><br><span class="line">//多级分类</span><br><span class="line">categories:</span><br><span class="line">  - 主分类</span><br><span class="line">  - 次分类</span><br><span class="line">//或者</span><br><span class="line">categories: [主分类,次分类]</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p> <a href="https://hexo.io/themes/">Themes | Hexo</a> </p>
<p>cd 博客目录</p>
<p>git clone 主题url</p>
<p> 将博客根目录下的 <code>_config.yml</code> 里的 <code>theme</code> 值修改成下载的主题</p>
<p>例：本博客采用Ayer</p>
<p>详情见	 <a href="https://shen-yu.gitee.io/2019/ayer/#%E5%AE%89%E8%A3%85">Ayer中文说明 | 岛 (gitee.io)</a> </p>
<h3 id="配置到远程仓库（码云）"><a href="#配置到远程仓库（码云）" class="headerlink" title="配置到远程仓库（码云）"></a>配置到远程仓库（码云）</h3><p>参考 <a href="https://blog.csdn.net/cungudafa/article/details/104260494?ops_request_misc=%7B%22request_id%22:%22164969418816782089398873%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=164969418816782089398873&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-104260494.142%5Ev7%5Epc_search_result_control_group,157%5Ev4%5Econtrol&utm_term=hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%B0gitee&spm=1018.2226.3001.4187">基于Gitee+Hexo搭建个人博客_cungudafa的博客-CSDN博客_gitee个人博客模板</a> </p>
<p>项目目录下 _config.yml 文件 修改 </p>
<p> ：后都有一个空格 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: 你的项目地址（https）</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>部署</p>
<p>需要下载插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save	</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g --d  #一键部署</span><br></pre></td></tr></table></figure>

<p>每次添加文件都要手动在gitee更新</p>
]]></content>
      <categories>
        <category>操作</category>
      </categories>
  </entry>
</search>
